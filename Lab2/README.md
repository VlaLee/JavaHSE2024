# Lab №2. Frequency Dictionary
---

## Introduction
Алгоритм действия программы:
1. Запросить у пользователя имя файла для чтения
2. Запросить у пользователя имя файла для записи
3. Проверить, что файл существует, не является директорией, не имеет проблем с доступом
4. Открыть файл на чтение
5. Для каждой буквы английского алфавита посчитать количество использований в файле (учитывая регистр)
6. Результаты записать в файл для записи

---
## Interfaces
* Интерфейс **Writer** обязывает все имплементирующие его классы переопределять метод **writeToFile()**. Образует семейство классов, способных записывать информацию в файл.
* Интерфейс **FrequencyDictionary** обязывает все имплементирующие его классы переопределять метод **fillDict()**, а также геттер **getDict()**. Образует семейство классов, способных как-либо проводить частотный анализ.

---
## Classes
* Класс **FrequencyFileDictionary** имплементирует интерфейсы **Writer** и **FrequencyDictionary**. Таким образом, этот класс имеет право и на частотный анализ, и на запись в файл одновременно благодаря интерфейсам.
* Класс **UserFileGetter** позволяет получать *корректные файлы* от пользователя. Имеет методы **getFileFromUser()**, который имеет под капотом реализации проверку на то, что введеный пользователем файл существует и не является директорией, **checkReadingAccess()** и **checkWritingAccess()**, который проверяет файл на доступ на чтение и запись.

---
## Exceptions
Все нижеописанные исключения наследуются от **IOException**.
* **FileIllegalArgumentException** - исключение, указывающее не неправильно переданный аргумент
* **FileAccessDeniedException** - исключение, указывающее на проблемы с доступом к файлу

---
## Additional functional
В классе **FrequencyFileDictionary** реализованы три конструктора. Первый принимает имена файлов для чтения и записи.

Если нужно, чтобы информация со словаря **A** перешла в словарь **B**, и словарь **B** так же будет считывать файл, то существует конструктор, который принимает первым аргументом словарь, с которого будут копировать информацию, второй и третие аргументы - имена файлов для чтения и записи.

Если нужно только скопировать данные со словаря **A** в словарь **B**, то достаточно первым аргументом передать словарь, а вторым - имя файла для записи.

Стоит заметить, что во 2 и 3 конструкторы не обязательно передавать словари типа **FrequencyFileDictionary**, достаточно передать словарь, имплементирующий интерфейс **FrequencyDictionary**.

Примеры работы 1 и 2 конструкторов смотрите ниже в разделе **Testing**.

---
## Testing
В классе Main производится основной запуск программы. Пример взаимодействия:
```
Enter the file for reading:
test1.txt
Enter the file for writing:
result.txt
Dictionary has been successfully filled using text from test1.txt
Information from dictionary has been recorded to result.txt
Enter the another file for reading:
test2.txt
Dictionary has been successfully filled using text from test2.txt
Information from dictionary has been recorded to result.txt
```
Файл result.txt:
```
A: 4
B: 7
C: 2
D: 1
...
X: 0
Y: 5
Z: 0
a: 240
b: 35
c: 73
...
u: 64
v: 50
w: 36
x: 11
y: 40
z: 3
```
Таким образом, сначала словарь был заполнен из файла **test1.txt**, записан в **result.txt**, после чего создался другой словарь, начальные данные которого были заполнены из первого словаря, после чего новый словарь дополнительно заполнился из файла **test2.txt**.

Пример взаимодействия, где пользователь передает несуществующий файл:
```
Enter the file for reading:
test1.txt
Enter the file for writing:
foo.txt
File D:\JavaProjects\FrequencyDictionary\foo.txt does not exist
```